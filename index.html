<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D ìŠˆí¼ ë§ˆë²• íŒŒí‹°í´ ì—°êµ¬ì†Œ ğŸŒŸ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: "Pretendard", -apple-system, sans-serif; }
        canvas { display: block; touch-action: none; }
        .glass-ui {
            background: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        button.active {
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.6);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .mode-btn { transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); border: 1px solid rgba(255,255,255,0.1); }
        .mode-btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <!-- UI ìƒë‹¨ -->
    <div class="fixed top-6 left-1/2 -translate-x-1/2 z-10 w-[95%] max-w-5xl text-center pointer-events-none">
        <h1 class="text-3xl font-black mb-1 tracking-tighter drop-shadow-2xl italic">âœ¨ 3D SUPER MAGIC âœ¨</h1>
        <p class="text-white/60 text-[10px] uppercase tracking-[0.3em] mb-4">í¬ê³  í™”ë ¤í•´ì§„ ë§ˆë²• íŒŒí‹°í´ì„ ê²½í—˜í•˜ì„¸ìš”</p>
        
        <div class="glass-ui p-3 rounded-[2rem] flex flex-wrap justify-center gap-2 pointer-events-auto">
            <button onclick="setMode('fireworks')" id="btn-fireworks" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold active">ğŸ† ëŒ€í­ë°œ</button>
            <button onclick="setMode('hearts')" id="btn-hearts" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸ’– í•‘í¬í•˜íŠ¸</button>
            <button onclick="setMode('stars')" id="btn-stars" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">â­ í™©ê¸ˆë³„ë¹›</button>
            <button onclick="setMode('lightning')" id="btn-lightning" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">âš¡ í‘¸ë¥¸ë²ˆê°œ</button>
            <button onclick="setMode('snow')" id="btn-snow" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">â„ï¸ ëˆˆì†¡ì´</button>
            <button onclick="setMode('petals')" id="btn-petals" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒ¸ ê½ƒì</button>
            <button onclick="setMode('bubbles')" id="btn-bubbles" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸ«§ ë¹„ëˆ—ë°©ìš¸</button>
            <button onclick="setMode('vortex')" id="btn-vortex" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒªï¸ ì†Œìš©ëŒì´</button>
            <button onclick="setMode('blackhole')" id="btn-blackhole" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒ€ ë¸”ë™í™€</button>
            <button onclick="setMode('rainbow')" id="btn-rainbow" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒˆ ë¬´ì§€ê°œ</button>
        </div>
    </div>

    <button onclick="toggleMute()" id="audio-toggle" class="fixed bottom-8 right-8 z-10 glass-ui w-14 h-14 rounded-full flex items-center justify-center text-2xl transition-all hover:scale-110 active:scale-90 shadow-2xl">ğŸ”Š</button>

    <div id="container"></div>

    <script>
        // --- 3D ì—”ì§„ ì„¤ì • (Three.js) ---
        let scene, camera, renderer, ambientParticlesGroup, magicParticlesGroup;
        let ambientParticles = []; 
        let magicParticles = [];   
        const mouse3D = new THREE.Vector3();
        const mouse2D = new THREE.Vector2();
        let mode = 'fireworks';
        let soundEnabled = true;
        let isPressed = false;
        let lastSoundTime = 0;

        // í•˜íŠ¸ ëª¨ì–‘ ì •ì˜ (Bezier Curve)
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 5);
        heartShape.bezierCurveTo(0, 5, -5, 12, -12, 12);
        heartShape.bezierCurveTo(-20, 12, -20, 0, -20, 0);
        heartShape.bezierCurveTo(-20, -10, -12, -18, 0, -28);
        heartShape.bezierCurveTo(12, -18, 20, -10, 20, 0);
        heartShape.bezierCurveTo(20, 0, 20, 12, 12, 12);
        heartShape.bezierCurveTo(5, 12, 0, 5, 0, 5);

        const petalShape = new THREE.Shape();
        petalShape.moveTo(0, 0);
        petalShape.bezierCurveTo(5, 5, 10, 15, 0, 25);
        petalShape.bezierCurveTo(-10, 15, -5, 5, 0, 0);

        const snowShape = new THREE.Shape();
        snowShape.moveTo(-1, 10); snowShape.lineTo(1, 10); snowShape.lineTo(1, 1);
        snowShape.lineTo(10, 1); snowShape.lineTo(10, -1); snowShape.lineTo(1, -1);
        snowShape.lineTo(1, -10); snowShape.lineTo(-1, -10); snowShape.lineTo(-1, -1);
        snowShape.lineTo(-10, -1); snowShape.lineTo(-10, 1); snowShape.lineTo(-1, 1);
        snowShape.lineTo(-1, 10);

        // --- ì‚¬ìš´ë“œ ì—”ì§„ ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playNoise(duration, volume, filterType, filterFreq) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = filterType;
            filter.frequency.setValueAtTime(filterFreq, audioCtx.currentTime);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
        }

        function playMagicSound(type, intensity = 1.0) {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;
            if (now - lastSoundTime < 0.04) return;
            lastSoundTime = now;
            const gain = audioCtx.createGain();
            gain.connect(audioCtx.destination);
            switch(type) {
                case 'fireworks':
                    const fOsc = audioCtx.createOscillator();
                    fOsc.frequency.setValueAtTime(150, now);
                    fOsc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                    gain.gain.setValueAtTime(0.3 * intensity, now);
                    fOsc.connect(gain); fOsc.start(); fOsc.stop(now + 0.15);
                    playNoise(0.2, 0.05, 'lowpass', 1000);
                    break;
                case 'lightning': playNoise(0.08, 0.15 * intensity, 'highpass', 2000); break;
                case 'bubbles':
                    const bOsc = audioCtx.createOscillator();
                    bOsc.frequency.setValueAtTime(1000, now);
                    bOsc.frequency.exponentialRampToValueAtTime(2500, now + 0.05);
                    gain.gain.setValueAtTime(0.12 * intensity, now);
                    bOsc.connect(gain); bOsc.start(); bOsc.stop(now + 0.08);
                    break;
                case 'blackhole':
                    const bhOsc = audioCtx.createOscillator();
                    bhOsc.frequency.setValueAtTime(120, now);
                    bhOsc.frequency.linearRampToValueAtTime(5, now + 0.4);
                    gain.gain.setValueAtTime(0.25 * intensity, now);
                    bhOsc.connect(gain); bhOsc.start(); bhOsc.stop(now + 0.4);
                    break;
                default:
                    const mOsc = audioCtx.createOscillator();
                    mOsc.type = 'triangle';
                    mOsc.frequency.setValueAtTime(type === 'hearts' ? 660 : 1200, now);
                    gain.gain.setValueAtTime(0.07 * intensity, now);
                    mOsc.connect(gain); mOsc.start(); mOsc.stop(now + 0.15);
            }
        }

        // --- íŒŒí‹°í´ ì‹œìŠ¤í…œ ---
        class MagicParticle {
            constructor(pos, isMagic = false) {
                this.isMagic = isMagic;
                this.life = 1.0;
                this.decay = isMagic ? (Math.random() * 0.01 + 0.008) : 0; // ìˆ˜ëª… ì¡°ê¸ˆ ë” ê¸¸ê²Œ
                
                // í¬ê¸° ëŒ€í­ ìƒí–¥ (íƒ€ê²©ê° í”¼ë“œë°±)
                const sizeBase = isMagic ? Math.random() * 8 + 6 : Math.random() * 2 + 1;
                let geometry;
                
                if (isMagic) {
                    switch(mode) {
                        case 'hearts': geometry = new THREE.ShapeGeometry(heartShape); break;
                        case 'stars': geometry = new THREE.OctahedronGeometry(sizeBase, 0); break;
                        case 'lightning': geometry = new THREE.TetrahedronGeometry(sizeBase, 0); break;
                        case 'snow': geometry = new THREE.ShapeGeometry(snowShape); break;
                        case 'petals': geometry = new THREE.ShapeGeometry(petalShape); break;
                        case 'bubbles': geometry = new THREE.SphereGeometry(sizeBase, 16, 16); break;
                        case 'vortex': geometry = new THREE.CylinderGeometry(0.1, sizeBase, sizeBase*2, 6); break;
                        case 'blackhole': geometry = new THREE.TorusGeometry(sizeBase, sizeBase*0.3, 8, 16); break;
                        case 'rainbow': geometry = new THREE.DodecahedronGeometry(sizeBase, 0); break;
                        default: geometry = new THREE.SphereGeometry(sizeBase, 8, 8);
                    }
                } else {
                    geometry = new THREE.SphereGeometry(sizeBase, 4, 4);
                }
                
                let color;
                if (isMagic) {
                    const r = Math.random;
                    switch(mode) {
                        case 'hearts': color = new THREE.Color(`hsl(${r() * 20 + 340}, 100%, 75%)`); break;
                        case 'stars': color = new THREE.Color(`hsl(${r() * 15 + 45}, 100%, 75%)`); break;
                        case 'bubbles': color = new THREE.Color(`hsla(${r() * 40 + 190}, 100%, 90%, 0.9)`); break;
                        case 'rainbow': color = new THREE.Color(`hsl(${r() * 360}, 100%, 65%)`); break;
                        default: color = new THREE.Color(`hsl(${r() * 360}, 100%, 70%)`);
                    }
                } else {
                    const h = Math.random() > 0.5 ? 260 : 320;
                    color = new THREE.Color(`hsl(${h}, 95%, 65%)`);
                }

                const materialOptions = { 
                    color: color, 
                    transparent: true, 
                    opacity: isMagic ? 1 : 0.8,
                    side: THREE.DoubleSide
                };

                if (isMagic && mode === 'bubbles') {
                    materialOptions.wireframe = true;
                    materialOptions.opacity = 0.7;
                    materialOptions.color = new THREE.Color(0xffffff);
                }

                const material = new THREE.MeshBasicMaterial(materialOptions);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(pos);

                // í•˜íŠ¸ëŠ” ê±°ê¾¸ë¡œ ìƒì„±ë˜ë¯€ë¡œ ë³´ì •
                if (isMagic && mode === 'hearts') this.mesh.rotation.z = Math.PI;

                // ë¬¼ë¦¬ ì´ˆê¸°í™”
                const r = Math.random;
                const angle = r() * Math.PI * 2;
                const phi = r() * Math.PI;
                // ì´ˆê¸° ì†ë„ ê°•í™”
                const force = isMagic ? (r() * 12 + 6) : (r() * 1.5 + 0.5);
                
                this.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(angle) * force,
                    Math.sin(phi) * Math.sin(angle) * force,
                    Math.cos(phi) * force
                );
                
                // ëŒ€í­ë°œ ì¤‘ë ¥ ë³µêµ¬
                this.gravity = (isMagic && mode === 'fireworks') ? -0.2 : 0;
                if (isMagic && (mode === 'bubbles' || mode === 'hearts' || mode === 'snow')) this.gravity = 0.08; 

                this.friction = 0.96;
                this.angleOffset = r() * Math.PI * 2;
                this.rotationSpeed = new THREE.Vector3(r()*0.2, r()*0.2, r()*0.2);
            }

            update() {
                if (this.isMagic) {
                    this.life -= this.decay;
                    this.mesh.material.opacity = Math.max(0, this.life);
                    
                    this.mesh.rotation.x += this.rotationSpeed.x;
                    this.mesh.rotation.y += this.rotationSpeed.y;
                    this.mesh.rotation.z += this.rotationSpeed.z;

                    if (mode === 'vortex') {
                        const vec = new THREE.Vector3().subVectors(mouse3D, this.mesh.position);
                        const dist = vec.length();
                        if (dist < 350) {
                            const axis = new THREE.Vector3(0, 1, 0);
                            this.velocity.applyAxisAngle(axis, 0.2); 
                            this.velocity.add(vec.normalize().multiplyScalar(0.6));
                        }
                    } else if (mode === 'blackhole') {
                        const vec = new THREE.Vector3().subVectors(mouse3D, this.mesh.position);
                        const dist = vec.length();
                        if (dist > 5) {
                            this.velocity.add(vec.normalize().multiplyScalar(1.5));
                            if (dist < 60) {
                                this.mesh.scale.multiplyScalar(0.92);
                                this.velocity.applyAxisAngle(new THREE.Vector3(0,0,1), 0.5);
                            }
                        }
                    }

                    this.velocity.y += this.gravity;
                    this.mesh.position.add(this.velocity);
                    this.velocity.multiplyScalar(this.friction);
                } else {
                    this.mesh.position.add(this.velocity);
                    this.velocity.x += Math.cos(Date.now() * 0.0008 + this.angleOffset) * 0.01;
                    this.velocity.y += Math.sin(Date.now() * 0.0008 + this.angleOffset) * 0.01;
                    this.velocity.multiplyScalar(0.995);
                    if (Math.abs(this.mesh.position.x) > 1000) this.velocity.x *= -1;
                    if (Math.abs(this.mesh.position.y) > 600) this.velocity.y *= -1;
                    if (Math.abs(this.mesh.position.z) > 600) this.velocity.z *= -1;
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 700;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            ambientParticlesGroup = new THREE.Group();
            magicParticlesGroup = new THREE.Group();
            scene.add(ambientParticlesGroup);
            scene.add(magicParticlesGroup);
            ambientParticles = [];
            magicParticles = [];
            for (let i = 0; i < 800; i++) {
                const pos = new THREE.Vector3((Math.random()-0.5)*2000,(Math.random()-0.5)*1200,(Math.random()-0.5)*1200);
                const p = new MagicParticle(pos, false);
                ambientParticlesGroup.add(p.mesh);
                ambientParticles.push(p);
            }
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onMouseUp);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMouse3D() {
            const vector = new THREE.Vector3(mouse2D.x, mouse2D.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            mouse3D.copy(camera.position).add(dir.multiplyScalar(distance));
        }

        function onMouseMove(e) {
            mouse2D.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse2D.y = -(e.clientY / window.innerHeight) * 2 + 1;
            updateMouse3D();
            if (isPressed) spawnMagic(false);
        }

        function onMouseDown(e) {
            initAudio(); isPressed = true; onMouseMove(e); spawnMagic(true);
        }

        function onMouseUp() { isPressed = false; }

        function onTouchStart(e) {
            e.preventDefault(); initAudio(); isPressed = true;
            updateTouch(e); spawnMagic(true);
        }

        function onTouchMove(e) {
            e.preventDefault(); updateTouch(e);
            if (isPressed) spawnMagic(false);
        }

        function updateTouch(e) {
            const touch = e.touches[0];
            mouse2D.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse2D.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            updateMouse3D();
        }

        function spawnMagic(isClick = false) {
            playMagicSound(mode, isClick ? 1.0 : 0.75);
            const count = isClick ? 100 : 25;
            for (let i = 0; i < count; i++) {
                const p = new MagicParticle(mouse3D, true);
                magicParticlesGroup.add(p.mesh);
                magicParticles.push(p);
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + newMode).classList.add('active');
            initAudio(); playMagicSound(newMode, 1.4);
        }

        function toggleMute() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('audio-toggle');
            btn.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            btn.style.opacity = soundEnabled ? '1' : '0.5';
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.position.x += (mouse2D.x * 150 - camera.position.x) * 0.05;
            camera.position.y += (mouse2D.y * 150 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);
            ambientParticles.forEach(p => p.update());
            for (let i = magicParticles.length - 1; i >= 0; i--) {
                const p = magicParticles[i];
                p.update();
                if (p.life <= 0) {
                    magicParticlesGroup.remove(p.mesh);
                    magicParticles.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>