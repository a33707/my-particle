<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Planet Hunter V3 ğŸŒŸ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: "Pretendard", -apple-system, sans-serif; }
        canvas { display: block; touch-action: none; }
        .glass-ui {
            background: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        button.active {
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.6);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .mode-btn { 
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); 
            border: 1px solid rgba(255,255,255,0.1);
            flex-shrink: 0; /* ìºëŸ¬ì…€ í˜•íƒœ ìœ ì§€ë¥¼ ìœ„í•´ í¬ê¸° ê³ ì • */
        }
        .mode-btn:active { transform: scale(0.95); }
        
        /* ìºëŸ¬ì…€ ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¸°ê¸° */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        #flash-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; pointer-events: none; opacity: 0; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="flash-overlay"></div>

    <!-- UI ìƒë‹¨: ìºëŸ¬ì…€ ë ˆì´ì•„ì›ƒ ì ìš© -->
    <div class="fixed top-4 md:top-6 left-1/2 -translate-x-1/2 z-50 w-full max-w-5xl text-center pointer-events-none px-4">
        <h1 class="text-xl md:text-3xl font-black mb-2 md:mb-1 tracking-tighter drop-shadow-2xl italic uppercase text-indigo-300">â˜„ï¸ PLANET HUNTER V3</h1>
        
        <!-- ë²„íŠ¼ ìºëŸ¬ì…€ ì»¨í…Œì´ë„ˆ -->
        <div class="glass-ui p-2 md:p-3 rounded-[1.5rem] md:rounded-[2rem] pointer-events-auto shadow-indigo-500/20">
            <div class="flex items-center gap-2 overflow-x-auto no-scrollbar snap-x snap-mandatory px-2">
                <button onclick="setMode('fireworks')" id="btn-fireworks" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold active snap-center">ğŸ† ëŒ€í­ë°œ</button>
                <button onclick="setMode('hearts')" id="btn-hearts" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸ’– í•‘í¬í•˜íŠ¸</button>
                <button onclick="setMode('stars')" id="btn-stars" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">â­ í™©ê¸ˆë³„ë¹›</button>
                <button onclick="setMode('lightning')" id="btn-lightning" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">âš¡ í‘¸ë¥¸ë²ˆê°œ</button>
                <button onclick="setMode('snow')" id="btn-snow" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">â„ï¸ ëˆˆì†¡ì´</button>
                <button onclick="setMode('petals')" id="btn-petals" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸŒ¸ ê½ƒì</button>
                <button onclick="setMode('bubbles')" id="btn-bubbles" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸ«§ ë¹„ëˆ—ë°©ìš¸</button>
                <button onclick="setMode('vortex')" id="btn-vortex" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸŒªï¸ ì†Œìš©ëŒì´</button>
                <button onclick="setMode('blackhole')" id="btn-blackhole" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸŒ€ ë¸”ë™í™€</button>
                <button onclick="setMode('rainbow')" id="btn-rainbow" class="mode-btn px-4 py-2.5 rounded-xl md:rounded-2xl text-xs font-bold snap-center">ğŸŒˆ ë¬´ì§€ê°œ</button>
            </div>
        </div>
    </div>

    <button onclick="toggleMute()" id="audio-toggle" class="fixed bottom-6 right-6 md:bottom-8 md:right-8 z-50 glass-ui w-14 h-14 rounded-full flex items-center justify-center text-2xl transition-all hover:scale-110 active:scale-90 shadow-2xl pointer-events-auto">ğŸ”Š</button>

    <div id="container"></div>

    <script>
        // --- í•˜ì´ë¸Œë¦¬ë“œ ì„¤ì • ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        const config = {
            maxParticles: isMobile ? 450 : 1800,
            planetCount: isMobile ? 12 : 18,
            pixelRatio: Math.min(window.devicePixelRatio, 2)
        };

        // --- ì—”ì§„ ë³€ìˆ˜ ---
        let scene, camera, renderer, magicParticlesGroup, planetsGroup;
        let magicParticles = [];   
        let planets = [];
        const mouse3D = new THREE.Vector3();
        const mouse2D = new THREE.Vector2(-10, -10);
        const raycaster = new THREE.Raycaster();
        let mode = 'fireworks';
        let soundEnabled = true;
        let isPressed = false;
        let lastSoundTime = 0;

        // --- í˜•ìƒ ì •ì˜ ---
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 5);
        heartShape.bezierCurveTo(0, 5, -5, 12, -12, 12);
        heartShape.bezierCurveTo(-20, 12, -20, 0, -20, 0);
        heartShape.bezierCurveTo(-20, -10, -12, -18, 0, -28);
        heartShape.bezierCurveTo(12, -18, 20, -10, 20, 0);
        heartShape.bezierCurveTo(20, 0, 20, 12, 12, 12);
        heartShape.bezierCurveTo(5, 12, 0, 5, 0, 5);

        const petalShape = new THREE.Shape();
        petalShape.moveTo(0, 0);
        petalShape.bezierCurveTo(5, 5, 10, 15, 0, 25);
        petalShape.bezierCurveTo(-10, 15, -5, 5, 0, 0);

        const snowShape = new THREE.Shape();
        snowShape.moveTo(-1, 10); snowShape.lineTo(1, 10); snowShape.lineTo(1, 1);
        snowShape.lineTo(10, 1); snowShape.lineTo(10, -1); snowShape.lineTo(1, -1);
        snowShape.lineTo(1, -10); snowShape.lineTo(-1, -10); snowShape.lineTo(-1, -1);
        snowShape.lineTo(-10, -1); snowShape.lineTo(-10, 1); snowShape.lineTo(-1, 1);
        snowShape.lineTo(-1, 10);

        // --- ì‚¬ìš´ë“œ ì—”ì§„ (V2 ë¡œì§ ì—„ê²© ìœ ì§€) ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoftNoise(duration, volume, freq) {
            if(!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(freq, audioCtx.currentTime);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
        }

        function playMagicSound(type, isClick = false) {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;
            const interval = isClick ? 0.05 : 0.25; 
            if (now - lastSoundTime < interval) return;
            lastSoundTime = now;

            const masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            const vol = isClick ? 0.15 : 0.04;

            switch(type) {
                case 'fireworks': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(isClick ? 80 : 60, now);
                    osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                    masterGain.gain.setValueAtTime(vol * 2, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.3);
                    break;
                }
                case 'hearts': {
                    const carrier = audioCtx.createOscillator();
                    const modulator = audioCtx.createOscillator();
                    const modGain = audioCtx.createGain();
                    carrier.type = 'sine'; modulator.type = 'sine';
                    const baseFreq = isClick ? 349.23 : 261.63 + (Math.random() * 5);
                    carrier.frequency.setValueAtTime(baseFreq, now);
                    modulator.frequency.setValueAtTime(baseFreq * 2, now);
                    modGain.gain.setValueAtTime(baseFreq * 0.5, now);
                    modulator.connect(modGain); modGain.connect(carrier.frequency);
                    carrier.connect(masterGain);
                    masterGain.gain.setValueAtTime(0, now);
                    masterGain.gain.linearRampToValueAtTime(vol, now + 0.05);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    carrier.start(); modulator.start();
                    carrier.stop(now + 0.5); modulator.stop(now + 0.5);
                    break;
                }
                case 'stars': {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(isClick ? 1200 : 900, now);
                    masterGain.gain.setValueAtTime(vol * 0.5, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.2);
                    break;
                }
                case 'lightning': playSoftNoise(0.1, vol * 1.5, 2000); break;
                case 'snow': playSoftNoise(0.4, vol * 0.4, 4000); break;
                case 'petals': playSoftNoise(0.6, vol * 0.3, 1000); break;
                case 'bubbles': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                    masterGain.gain.setValueAtTime(vol, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.1);
                    break;
                }
                case 'vortex': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(300, now + 0.4);
                    masterGain.gain.setValueAtTime(vol * 0.5, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.4);
                    break;
                }
                case 'blackhole': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(40, now + 0.6);
                    masterGain.gain.setValueAtTime(vol, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.6);
                    break;
                }
                case 'rainbow': {
                    const freqs = isClick ? [440, 554, 659] : [261, 329, 392];
                    freqs.forEach(f => {
                        const osc = audioCtx.createOscillator();
                        osc.frequency.setValueAtTime(f, now);
                        const g = audioCtx.createGain();
                        g.gain.setValueAtTime(vol * 0.3, now);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                        osc.connect(g); g.connect(audioCtx.destination);
                        osc.start(); osc.stop(now + 0.8);
                    });
                    break;
                }
            }
        }

        // --- íŒŒí‹°í´ ë° í–‰ì„± í´ë˜ìŠ¤ ---

        class MagicParticle {
            constructor(pos, isMagic = true, isExplosion = false, isClick = false) {
                this.life = 1.0;
                this.decay = Math.random() * 0.015 + (isExplosion ? 0.005 : 0.012); 
                const sizeBase = (Math.random() * 8 + 8) * (isExplosion ? 1.5 : 1.0);
                let geometry;
                
                switch(mode) {
                    case 'hearts': geometry = new THREE.ExtrudeGeometry(heartShape, { depth: 4, bevelEnabled: true, bevelThickness: 1, bevelSize: 1, bevelSegments: 3 }); break;
                    case 'stars': geometry = new THREE.OctahedronGeometry(sizeBase, 0); break;
                    case 'lightning': geometry = new THREE.TetrahedronGeometry(sizeBase, 0); break;
                    case 'snow': geometry = new THREE.ShapeGeometry(snowShape); break;
                    case 'petals': geometry = new THREE.ShapeGeometry(petalShape); break;
                    case 'bubbles': geometry = new THREE.SphereGeometry(sizeBase, 5, 4); break;
                    case 'vortex': geometry = new THREE.CylinderGeometry(0.1, sizeBase, sizeBase*2, 6); break;
                    case 'blackhole': geometry = new THREE.TorusGeometry(sizeBase, sizeBase*0.3, 8, 16); break;
                    case 'rainbow': geometry = new THREE.DodecahedronGeometry(sizeBase, 0); break;
                    default: geometry = new THREE.SphereGeometry(sizeBase, 8, 8);
                }
                
                const r = Math.random;
                let color;
                switch(mode) {
                    case 'hearts': color = new THREE.Color(`hsl(${r() * 20 + 340}, 100%, 75%)`); break;
                    case 'stars': color = new THREE.Color(`hsl(${r() * 15 + 45}, 100%, 75%)`); break;
                    case 'rainbow': color = new THREE.Color(`hsl(${r() * 360}, 100%, 70%)`); break;
                    default: color = new THREE.Color(`hsl(${r() * 360}, 100%, 80%)`);
                }

                const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1, side: THREE.DoubleSide, wireframe: (mode === 'bubbles') });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(pos);
                if (mode === 'hearts') { this.mesh.rotation.z = Math.PI; this.mesh.scale.set(0.4, 0.4, 0.4); }

                const force = isExplosion ? 45 : (isClick ? 25 : 12);
                this.velocity = new THREE.Vector3((r()-0.5)*force, (r()-0.5)*force, (r()-0.5)*force);
                this.gravity = (mode === 'fireworks') ? -0.4 : 0.05;
                this.friction = 0.95;
            }

            update() {
                this.life -= this.decay;
                this.mesh.material.opacity = Math.max(0, this.life);
                this.mesh.rotation.x += 0.1;
                this.velocity.y += this.gravity;
                this.mesh.position.add(this.velocity);
                this.velocity.multiplyScalar(this.friction);
                if (this.life < 0.2) this.mesh.scale.multiplyScalar(0.92);
            }
        }

        class Planet {
            constructor() {
                this.maxHp = 3 + Math.floor(Math.random() * 3);
                this.hp = this.maxHp;
                this.isDestroyed = false;
                this.shake = 0;
                
                const radius = 75 + Math.random() * 60; // í–‰ì„± í¬ê¸° í™•ëŒ€
                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                this.baseColor = new THREE.Color(`hsl(${Math.random() * 360}, 50%, 45%)`);
                this.material = new THREE.MeshStandardMaterial({ 
                    color: this.baseColor, roughness: 0.8, emissive: this.baseColor, emissiveIntensity: 0.3 
                });
                
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.userData = { parent: this };

                this.hpLabel = this.createHPLabel();
                this.mesh.add(this.hpLabel);
                this.hpLabel.position.set(0, radius + 30, 0);

                this.reset();
            }

            createHPLabel() {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const context = canvas.getContext('2d');
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(80, 80, 1);
                sprite.userData.context = context;
                sprite.userData.texture = texture;
                return sprite;
            }

            updateHPLabel() {
                const context = this.hpLabel.userData.context;
                const texture = this.hpLabel.userData.texture;
                context.clearRect(0, 0, 128, 128);
                context.font = 'bold 90px Pretendard';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.shadowColor = 'rgba(0,0,0,0.9)';
                context.shadowBlur = 12;
                context.fillText(this.hp, 64, 90);
                texture.needsUpdate = true;
            }

            reset() {
                this.hp = this.maxHp;
                this.isDestroyed = false;
                this.mesh.visible = true;
                this.updateHPLabel();
                this.mesh.position.set((Math.random()-0.5)*2600, (Math.random()-0.5)*1800, (Math.random()-0.5)*1000 - 500);
                this.velocity = new THREE.Vector3((Math.random()-0.5)*1.4, (Math.random()-0.5)*1.4, (Math.random()-0.5)*0.5);
                this.rotationVel = new THREE.Vector3(Math.random()*0.01, Math.random()*0.01, Math.random()*0.01);
            }

            hit(point) {
                if (this.isDestroyed) return;
                this.hp--;
                this.shake = 30; 
                
                spawnMagic(point || this.mesh.position, true, false, isMobile ? 12 : 22);
                
                if (this.hp <= 0) {
                    this.isDestroyed = true;
                    this.mesh.visible = false;
                    this.hpLabel.material.opacity = 0;
                    
                    triggerFlash();
                    playMagicSound(mode, true);
                    spawnMagic(this.mesh.position, true, true, isMobile ? 80 : 150); // íŒŒê´´ í­ë°œ
                    setTimeout(() => this.reset(), 4000);
                } else {
                    this.updateHPLabel();
                    playMagicSound(mode, false);
                    this.material.emissiveIntensity = 12.0;
                }
            }

            update() {
                if (this.isDestroyed) return;
                this.mesh.position.add(this.velocity);
                this.mesh.rotation.x += this.rotationVel.x;
                this.mesh.rotation.y += this.rotationVel.y;

                if (this.shake > 0) {
                    this.mesh.position.x += (Math.random()-0.5) * this.shake;
                    this.mesh.position.y += (Math.random()-0.5) * this.shake;
                    this.shake *= 0.8;
                    this.material.emissiveIntensity = Math.max(0.3, this.shake * 0.5);
                } else {
                    const ratio = this.hp / this.maxHp;
                    this.material.emissiveIntensity = (1-ratio) * 3 + 0.3;
                }

                if (Math.abs(this.mesh.position.x) > 1600) this.velocity.x *= -1;
                if (Math.abs(this.mesh.position.y) > 1200) this.velocity.y *= -1;
                this.hpLabel.material.opacity = this.mesh.visible ? 1 : 0;
            }
        }

        // --- ë¡œì§ ë° ì‹¤í–‰ ---

        function triggerFlash() {
            const flash = document.getElementById('flash-overlay');
            flash.style.opacity = '0.6';
            setTimeout(() => flash.style.opacity = '0', 250);
        }

        function spawnMagic(pos, isClick = false, isExplosion = false, count = 1) {
            for(let i=0; i < count; i++) {
                if (magicParticles.length > config.maxParticles) {
                    const old = magicParticles.shift();
                    magicParticlesGroup.remove(old.mesh);
                    if(old.mesh.geometry) old.mesh.geometry.dispose();
                    if(old.mesh.material) old.mesh.material.dispose();
                }
                const p = new MagicParticle(pos, true, isExplosion, isClick);
                magicParticlesGroup.add(p.mesh);
                magicParticles.push(p);
            }
        }

        function checkHit() {
            raycaster.setFromCamera(mouse2D, camera);
            const intersects = raycaster.intersectObjects(planetsGroup.children);
            if (intersects.length > 0) {
                const planet = intersects[0].object.userData.parent;
                const now = Date.now();
                if (now - (planet.lastHit || 0) > 120) {
                    planet.hit(intersects[0].point);
                    planet.lastHit = now;
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 20000);
            camera.position.z = 1200;

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
            renderer.setPixelRatio(config.pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);
            
            const light = new THREE.PointLight(0xffffff, 3.5, 10000);
            light.position.set(0, 800, 1500);
            scene.add(light, new THREE.AmbientLight(0x777777));

            magicParticlesGroup = new THREE.Group();
            planetsGroup = new THREE.Group();
            scene.add(magicParticlesGroup, planetsGroup);

            for (let i = 0; i < config.planetCount; i++) {
                const p = new Planet();
                planets.push(p);
                planetsGroup.add(p.mesh);
            }

            const starGeom = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<2500; i++) starPos.push((Math.random()-0.5)*12000, (Math.random()-0.5)*10000, (Math.random()-1)*7000);
            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            scene.add(new THREE.Points(starGeom, new THREE.PointsMaterial({ color: 0xffffff, size: 2.8, transparent: true, opacity: 0.7 })));

            window.addEventListener('resize', onWindowResize);
            
            const handleInput = (x, y, isStart) => {
                mouse2D.x = (x / window.innerWidth) * 2 - 1;
                mouse2D.y = -(y / window.innerHeight) * 2 + 1;
                
                const vector = new THREE.Vector3(mouse2D.x, mouse2D.y, 0.5).unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                mouse3D.copy(camera.position).add(dir.multiplyScalar(-camera.position.z / dir.z));
                
                if (isStart) initAudio();
                spawnMagic(mouse3D, isStart, false, isStart ? 25 : 8);
                checkHit();
            };

            document.addEventListener('touchstart', (e) => { 
                if (e.target.closest('.glass-ui')) return; // UI í„°ì¹˜ ì‹œ ê²Œì„ ë°˜ì‘ ì°¨ë‹¨
                e.preventDefault(); isPressed = true;
                handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (!isPressed) return;
                e.preventDefault();
                handleInput(e.touches[0].clientX, e.touches[0].clientY, false);
            }, { passive: false });
            
            document.addEventListener('touchend', () => isPressed = false);
            document.addEventListener('mousedown', (e) => {
                if (e.target.closest('.glass-ui')) return;
                isPressed = true; handleInput(e.clientX, e.clientY, true);
            });
            document.addEventListener('mousemove', (e) => { if(isPressed) handleInput(e.clientX, e.clientY, false); });
            window.addEventListener('mouseup', () => isPressed = false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setMode(m) {
            mode = m;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + m).classList.add('active');
            initAudio(); playMagicSound(m, true);
        }

        function toggleMute() {
            soundEnabled = !soundEnabled;
            document.getElementById('audio-toggle').textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
        }

        function animate() {
            requestAnimationFrame(animate);
            planets.forEach(p => p.update());
            for (let i = magicParticles.length - 1; i >= 0; i--) {
                const p = magicParticles[i]; p.update();
                if (p.life <= 0) {
                    magicParticlesGroup.remove(p.mesh);
                    magicParticles.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>