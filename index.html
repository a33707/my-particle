<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D ìŠˆí¼ ë§ˆë²• íŒŒí‹°í´ ì—°êµ¬ì†Œ ğŸŒŸ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: "Pretendard", -apple-system, sans-serif; }
        canvas { display: block; touch-action: none; }
        .glass-ui {
            background: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
        }
        button.active {
            background: linear-gradient(135deg, #4f46e5, #ec4899);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(236, 72, 153, 0.6);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .mode-btn { transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); border: 1px solid rgba(255,255,255,0.1); }
        .mode-btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <!-- UI ìƒë‹¨ -->
    <div class="fixed top-6 left-1/2 -translate-x-1/2 z-10 w-[95%] max-w-5xl text-center pointer-events-none">
        <h1 class="text-3xl font-black mb-1 tracking-tighter drop-shadow-2xl italic">âœ¨ 3D SUPER MAGIC âœ¨</h1>
        <p class="text-white/60 text-[10px] uppercase tracking-[0.3em] mb-4">ë“œë˜ê·¸ ë¦¬ë“¬ì— ë§ì¶° ë³€í•˜ëŠ” ë¶€ë“œëŸ¬ìš´ ë§ˆë²• ì‚¬ìš´ë“œ</p>
        
        <div class="glass-ui p-3 rounded-[2rem] flex flex-wrap justify-center gap-2 pointer-events-auto">
            <button onclick="setMode('fireworks')" id="btn-fireworks" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold active">ğŸ† ëŒ€í­ë°œ</button>
            <button onclick="setMode('hearts')" id="btn-hearts" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸ’– í•‘í¬í•˜íŠ¸</button>
            <button onclick="setMode('stars')" id="btn-stars" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">â­ í™©ê¸ˆë³„ë¹›</button>
            <button onclick="setMode('lightning')" id="btn-lightning" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">âš¡ í‘¸ë¥¸ë²ˆê°œ</button>
            <button onclick="setMode('snow')" id="btn-snow" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">â„ï¸ ëˆˆì†¡ì´</button>
            <button onclick="setMode('petals')" id="btn-petals" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒ¸ ê½ƒì</button>
            <button onclick="setMode('bubbles')" id="btn-bubbles" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸ«§ ë¹„ëˆ—ë°©ìš¸</button>
            <button onclick="setMode('vortex')" id="btn-vortex" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒªï¸ ì†Œìš©ëŒì´</button>
            <button onclick="setMode('blackhole')" id="btn-blackhole" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒ€ ë¸”ë™í™€</button>
            <button onclick="setMode('rainbow')" id="btn-rainbow" class="mode-btn px-3 py-2 rounded-2xl text-xs font-bold">ğŸŒˆ ë¬´ì§€ê°œ</button>
        </div>
    </div>

    <button onclick="toggleMute()" id="audio-toggle" class="fixed bottom-8 right-8 z-10 glass-ui w-14 h-14 rounded-full flex items-center justify-center text-2xl transition-all hover:scale-110 active:scale-90 shadow-2xl">ğŸ”Š</button>

    <div id="container"></div>

    <script>
        // --- 3D ì—”ì§„ ì„¤ì • (Three.js) ---
        let scene, camera, renderer, ambientParticlesGroup, magicParticlesGroup;
        let ambientParticles = []; 
        let magicParticles = [];   
        const mouse3D = new THREE.Vector3();
        const mouse2D = new THREE.Vector2();
        let mode = 'fireworks';
        let soundEnabled = true;
        let isPressed = false;
        let lastSoundTime = 0;

        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 5);
        heartShape.bezierCurveTo(0, 5, -5, 12, -12, 12);
        heartShape.bezierCurveTo(-20, 12, -20, 0, -20, 0);
        heartShape.bezierCurveTo(-20, -10, -12, -18, 0, -28);
        heartShape.bezierCurveTo(12, -18, 20, -10, 20, 0);
        heartShape.bezierCurveTo(20, 0, 20, 12, 12, 12);
        heartShape.bezierCurveTo(5, 12, 0, 5, 0, 5);

        const petalShape = new THREE.Shape();
        petalShape.moveTo(0, 0);
        petalShape.bezierCurveTo(5, 5, 10, 15, 0, 25);
        petalShape.bezierCurveTo(-10, 15, -5, 5, 0, 0);

        const snowShape = new THREE.Shape();
        snowShape.moveTo(-1, 10); snowShape.lineTo(1, 10); snowShape.lineTo(1, 1);
        snowShape.lineTo(10, 1); snowShape.lineTo(10, -1); snowShape.lineTo(1, -1);
        snowShape.lineTo(1, -10); snowShape.lineTo(-1, -10); snowShape.lineTo(-1, -1);
        snowShape.lineTo(-10, -1); snowShape.lineTo(-10, 1); snowShape.lineTo(-1, 1);
        snowShape.lineTo(-1, 10);

        // --- ì‚¬ìš´ë“œ ì—”ì§„ (ë§¥ë½ ì¤‘ì‹¬ ì‚¬ìš´ë“œ ë””ìì¸) ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function playSoftNoise(duration, volume, freq) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(freq, audioCtx.currentTime);
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
        }

        function playMagicSound(type, isClick = false) {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;
            
            // ë“œë˜ê·¸ ì¤‘ì—ëŠ” ì†Œë¦¬ íŠ¸ë¦¬ê±° ê°„ê²©ì„ í›¨ì”¬ ê¸¸ê²Œ í•˜ì—¬ 'ì›…ì„±ê±°ë¦¼' ë°©ì§€
            const interval = isClick ? 0.05 : 0.25; 
            if (now - lastSoundTime < interval) return;
            lastSoundTime = now;

            const masterGain = audioCtx.createGain();
            masterGain.connect(audioCtx.destination);
            // ë“œë˜ê·¸ ì‹œ ë³¼ë¥¨ì„ ì•„ì£¼ ë¯¸ì„¸í•˜ê²Œ ì„¤ì •
            const vol = isClick ? 0.15 : 0.04;

            switch(type) {
                case 'fireworks': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(isClick ? 80 : 60, now);
                    osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
                    masterGain.gain.setValueAtTime(vol * 2, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.3);
                    break;
                }
                case 'hearts': {
                    // í•‘í¬í•˜íŠ¸: ë¶€ë“œëŸ½ê³  ë”°ëœ»í•œ ìš¸ë¦¼ (FM í•©ì„± ëŠë‚Œ)
                    const carrier = audioCtx.createOscillator();
                    const modulator = audioCtx.createOscillator();
                    const modGain = audioCtx.createGain();

                    carrier.type = 'sine';
                    modulator.type = 'sine';
                    
                    const baseFreq = isClick ? 349.23 : 261.63 + (Math.random() * 5); // F4 vs C4
                    carrier.frequency.setValueAtTime(baseFreq, now);
                    modulator.frequency.setValueAtTime(baseFreq * 2, now);
                    modGain.gain.setValueAtTime(baseFreq * 0.5, now);

                    modulator.connect(modGain);
                    modGain.connect(carrier.frequency);
                    carrier.connect(masterGain);

                    masterGain.gain.setValueAtTime(0, now);
                    masterGain.gain.linearRampToValueAtTime(vol, now + 0.05); // ì–´íƒ ë¶€ë“œëŸ½ê²Œ
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

                    carrier.start(); modulator.start();
                    carrier.stop(now + 0.5); modulator.stop(now + 0.5);
                    break;
                }
                case 'stars': {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(isClick ? 1200 : 900, now);
                    masterGain.gain.setValueAtTime(vol * 0.5, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.2);
                    break;
                }
                case 'lightning': {
                    playSoftNoise(0.1, vol * 1.5, 2000);
                    break;
                }
                case 'snow': {
                    playSoftNoise(0.4, vol * 0.4, 4000);
                    break;
                }
                case 'petals': {
                    playSoftNoise(0.6, vol * 0.3, 1000);
                    break;
                }
                case 'bubbles': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                    masterGain.gain.setValueAtTime(vol, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.1);
                    break;
                }
                case 'vortex': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(300, now + 0.4);
                    masterGain.gain.setValueAtTime(vol * 0.5, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.4);
                    break;
                }
                case 'blackhole': {
                    const osc = audioCtx.createOscillator();
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(40, now + 0.6);
                    masterGain.gain.setValueAtTime(vol, now);
                    masterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                    osc.connect(masterGain); osc.start(); osc.stop(now + 0.6);
                    break;
                }
                case 'rainbow': {
                    const freqs = isClick ? [440, 554, 659] : [261, 329, 392];
                    freqs.forEach(f => {
                        const osc = audioCtx.createOscillator();
                        osc.frequency.setValueAtTime(f, now);
                        const g = audioCtx.createGain();
                        g.gain.setValueAtTime(vol * 0.3, now);
                        g.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                        osc.connect(g); g.connect(audioCtx.destination);
                        osc.start(); osc.stop(now + 0.8);
                    });
                    break;
                }
            }
        }

        function toggleMute() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('audio-toggle');
            btn.textContent = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
            btn.style.opacity = soundEnabled ? '1' : '0.5';
        }

        // --- íŒŒí‹°í´ ì‹œìŠ¤í…œ ---
        class MagicParticle {
            constructor(pos, isMagic = false) {
                this.isMagic = isMagic;
                this.life = 1.0;
                this.decay = isMagic ? (Math.random() * 0.01 + 0.008) : 0; 
                
                const sizeBase = isMagic ? Math.random() * 8 + 8 : Math.random() * 2 + 1;
                let geometry;
                
                if (isMagic) {
                    switch(mode) {
                        case 'hearts': 
                            geometry = new THREE.ExtrudeGeometry(heartShape, { 
                                depth: 4, bevelEnabled: true, bevelThickness: 1, bevelSize: 1, bevelSegments: 3 
                            }); 
                            break;
                        case 'stars': geometry = new THREE.OctahedronGeometry(sizeBase, 0); break;
                        case 'lightning': geometry = new THREE.TetrahedronGeometry(sizeBase, 0); break;
                        case 'snow': geometry = new THREE.ShapeGeometry(snowShape); break;
                        case 'petals': geometry = new THREE.ShapeGeometry(petalShape); break;
                        case 'bubbles': geometry = new THREE.SphereGeometry(sizeBase, 5, 4); break;
                        case 'vortex': geometry = new THREE.CylinderGeometry(0.1, sizeBase, sizeBase*2, 6); break;
                        case 'blackhole': geometry = new THREE.TorusGeometry(sizeBase, sizeBase*0.3, 8, 16); break;
                        case 'rainbow': geometry = new THREE.DodecahedronGeometry(sizeBase, 0); break;
                        default: geometry = new THREE.SphereGeometry(sizeBase, 8, 8);
                    }
                } else {
                    geometry = new THREE.SphereGeometry(sizeBase, 4, 4);
                }
                
                const r = Math.random;
                let color;
                if (isMagic) {
                    switch(mode) {
                        case 'hearts': color = new THREE.Color(`hsl(${r() * 20 + 340}, 100%, 75%)`); break;
                        case 'stars': color = new THREE.Color(`hsl(${r() * 15 + 45}, 100%, 75%)`); break;
                        case 'bubbles': color = new THREE.Color(0xaaccff); break; 
                        case 'rainbow': color = new THREE.Color(`hsl(${r() * 360}, 100%, 65%)`); break;
                        default: color = new THREE.Color(`hsl(${r() * 360}, 100%, 70%)`);
                    }
                } else {
                    const h = r() > 0.5 ? 260 : 320;
                    color = new THREE.Color(`hsl(${h}, 95%, 65%)`);
                }

                const materialOptions = { color: color, transparent: true, opacity: isMagic ? 1 : 0.8, side: THREE.DoubleSide };
                if (isMagic && mode === 'bubbles') { materialOptions.wireframe = true; materialOptions.opacity = 0.9; }

                const material = new THREE.MeshBasicMaterial(materialOptions);
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(pos);

                if (isMagic && mode === 'hearts') this.mesh.rotation.z = Math.PI;

                const angle = r() * Math.PI * 2;
                const phi = r() * Math.PI;
                const force = isMagic ? (r() * 12 + 6) : (r() * 1.5 + 0.5);
                
                this.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(angle) * force,
                    Math.sin(phi) * Math.sin(angle) * force,
                    Math.cos(phi) * force
                );
                
                this.gravity = (isMagic && mode === 'fireworks') ? -0.2 : 0;
                if (isMagic && (mode === 'bubbles' || mode === 'hearts' || mode === 'snow')) this.gravity = 0.08; 

                this.friction = 0.96;
                this.angleOffset = r() * Math.PI * 2;
                this.rotationSpeed = new THREE.Vector3(r()*0.2, r()*0.2, r()*0.2);
            }

            update() {
                if (this.isMagic) {
                    this.life -= this.decay;
                    this.mesh.material.opacity = Math.max(0, this.life);
                    this.mesh.rotation.x += this.rotationSpeed.x;
                    this.mesh.rotation.y += this.rotationSpeed.y;
                    this.mesh.rotation.z += this.rotationSpeed.z;

                    if (mode === 'vortex') {
                        const vec = new THREE.Vector3().subVectors(mouse3D, this.mesh.position);
                        const dist = vec.length();
                        if (dist < 350) {
                            const axis = new THREE.Vector3(0, 1, 0);
                            this.velocity.applyAxisAngle(axis, 0.2); 
                            this.velocity.add(vec.normalize().multiplyScalar(0.6));
                        }
                    } else if (mode === 'blackhole') {
                        const vec = new THREE.Vector3().subVectors(mouse3D, this.mesh.position);
                        const dist = vec.length();
                        if (dist > 5) {
                            this.velocity.add(vec.normalize().multiplyScalar(1.5));
                            if (dist < 60) { this.mesh.scale.multiplyScalar(0.92); this.velocity.applyAxisAngle(new THREE.Vector3(0,0,1), 0.5); }
                        }
                    }

                    this.velocity.y += this.gravity;
                    this.mesh.position.add(this.velocity);
                    this.velocity.multiplyScalar(this.friction);
                } else {
                    this.mesh.position.add(this.velocity);
                    this.velocity.x += Math.cos(Date.now() * 0.0008 + this.angleOffset) * 0.01;
                    this.velocity.y += Math.sin(Date.now() * 0.0008 + this.angleOffset) * 0.01;
                    this.velocity.multiplyScalar(0.995);
                    if (Math.abs(this.mesh.position.x) > 1000) this.velocity.x *= -1;
                    if (Math.abs(this.mesh.position.y) > 600) this.velocity.y *= -1;
                    if (Math.abs(this.mesh.position.z) > 600) this.velocity.z *= -1;
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 700;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            ambientParticlesGroup = new THREE.Group();
            magicParticlesGroup = new THREE.Group();
            scene.add(ambientParticlesGroup);
            scene.add(magicParticlesGroup);
            ambientParticles = [];
            magicParticles = [];
            for (let i = 0; i < 800; i++) {
                const pos = new THREE.Vector3((Math.random()-0.5)*2000,(Math.random()-0.5)*1200,(Math.random()-0.5)*1200);
                const p = new MagicParticle(pos, false);
                ambientParticlesGroup.add(p.mesh);
                ambientParticles.push(p);
            }
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onMouseUp);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateMouse3D() {
            const vector = new THREE.Vector3(mouse2D.x, mouse2D.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            mouse3D.copy(camera.position).add(dir.multiplyScalar(distance));
        }

        function onMouseMove(e) {
            mouse2D.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse2D.y = -(e.clientY / window.innerHeight) * 2 + 1;
            updateMouse3D();
            if (isPressed) spawnMagic(false);
        }

        function onMouseDown(e) {
            initAudio(); isPressed = true; onMouseMove(e); spawnMagic(true);
        }

        function onMouseUp() { isPressed = false; }

        function onTouchStart(e) { e.preventDefault(); initAudio(); isPressed = true; updateTouch(e); spawnMagic(true); }

        function onTouchMove(e) { e.preventDefault(); updateTouch(e); if (isPressed) spawnMagic(false); }

        function updateTouch(e) {
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                mouse2D.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse2D.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                updateMouse3D();
            }
        }

        function spawnMagic(isClick = false) {
            playMagicSound(mode, isClick);
            const count = isClick ? 100 : 25;
            for (let i = 0; i < count; i++) {
                const p = new MagicParticle(mouse3D, true);
                magicParticlesGroup.add(p.mesh);
                magicParticles.push(p);
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + newMode).classList.add('active');
            initAudio(); playMagicSound(newMode, true);
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.position.x += (mouse2D.x * 150 - camera.position.x) * 0.05;
            camera.position.y += (mouse2D.y * 150 - camera.position.y) * 0.05;
            camera.lookAt(scene.position);
            ambientParticles.forEach(p => p.update());
            for (let i = magicParticles.length - 1; i >= 0; i--) {
                const p = magicParticles[i];
                p.update();
                if (p.life <= 0) { magicParticlesGroup.remove(p.mesh); magicParticles.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>